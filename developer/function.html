<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CMakePP Function Implementation &mdash; CMakePPLang 1.0.0alpha documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> CMakePPLang
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features/index.html">Language Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conventions.html">Language Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugging.html">Debugging Code Written in CMakePPLang</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Developing CMakePP</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CMakePPLang</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>CMakePP Function Implementation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/developer/function.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cmakepp-function-implementation">
<h1>CMakePP Function Implementation<a class="headerlink" href="#cmakepp-function-implementation" title="Permalink to this headline"></a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since <cite>cpp_function</cite> does not appear to exist anymore, this page is not
included in the documentation.</p>
</div>
<p>This page describes how functions work in the CMakePP language.</p>
<section id="what-it-looks-like-to-the-user">
<h2>What it Looks Like to the User<a class="headerlink" href="#what-it-looks-like-to-the-user" title="Permalink to this headline"></a></h2>
<p>To frame our developer discussion let’s reiterate how CMakePP functions look to
users of the CMakePP language. To that end, let’s assume our user is declaring
a function <code class="docutils literal notranslate"><span class="pre">foo</span></code>, which takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> and a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. For this scenario,
the user writes code something akin to:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">include</span><span class="p">(</span><span class="s">cmakepp_lang/function/function</span><span class="p">)</span>

<span class="nb">cpp_function</span><span class="p">(</span><span class="s">foo</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="p">)</span>
<span class="nb">function</span><span class="p">(</span><span class="o">${</span><span class="nv">foo</span><span class="o">}</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Implement the foo(int, bool) function</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>When this code is run it will introduce a function <code class="docutils literal notranslate"><span class="pre">foo</span></code> into the current
scope. It is expected that users will be writing CMakePP functions in CMake
modules, hence usage of <code class="docutils literal notranslate"><span class="pre">foo</span></code> looks something like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">include</span><span class="p">(</span><span class="s">path/to/foo/module</span><span class="p">)</span>

<span class="nb">foo</span><span class="p">(</span><span class="s">3</span><span class="w"> </span><span class="s">TRUE</span><span class="p">)</span>
</pre></div>
</div>
<p>It bears mentioning that functions in the CMakePP language can be variadic and
they can be overloaded for different numbers/types of positional arguments.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline"></a></h2>
<p>Like C++, each overload of a function is actually mapped to a unique name. The
process of mapping overloads to unique names is called <strong>name mangling</strong>. It
is the mangled name that is returned from <cite>cpp_function</cite>. Hence, when a user
does:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cpp_function</span><span class="p">(</span><span class="s">foo</span><span class="w"> </span><span class="s">int</span><span class="p">)</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${foo}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>What they are really doing is defining a function whose name is the mangled
name. In order to give the user the illusion of overloads, as part of
<cite>cpp_function</cite>, the CMakePP language creates a wrapper function <code class="docutils literal notranslate"><span class="pre">foo</span></code> whose
contents are:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">macro</span><span class="p">(</span><span class="s">foo</span><span class="p">)</span>
<span class="w">    </span><span class="nb">_cpp_function_call_overload</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="o">${</span><span class="nv">ARGN</span><span class="o">}</span><span class="p">)</span>
<span class="nb">endmacro</span><span class="p">()</span>
</pre></div>
</div>
<p>This wrapper ultimately mangles the name of the function with the arguments,
then uses the initializer function pattern to call the implementation defined
under the mangled name.</p>
<p>Determining the mangled name is a little bit tricky because the same set of
objects could conceivably be given to multiple overloads. For example, calling
<code class="docutils literal notranslate"><span class="pre">foo(3</span> <span class="pre">hello)</span></code> could be perceived as trying to call <code class="docutils literal notranslate"><span class="pre">foo(int</span> <span class="pre">desc)</span></code>,
<code class="docutils literal notranslate"><span class="pre">foo(int</span> <span class="pre">args)</span></code>, or <code class="docutils literal notranslate"><span class="pre">foo(args)</span></code>. While the CMakePP language forbids the
user from defining more than one of these overloads at any given time, we
still need to know which overload the user defined. Rather than try all of the
possible overloads (the number of which grows linearly with the number of
arguments, ignoring implicit casts, or exponentially when we need to try
combinations of implicit casts) the CMakePP language simply keeps a record of
the overloads the user has defined so far for the function. This record is held
in a global map whose keys are the types provided to the signature and the
values are the mangled names. In practice, users tend to only define a couple
overloads for a function so we only need to consider an approximately constant
number of overloads.</p>
<p>The process is summarized in the following UML diagram.</p>
<img alt="../_images/cpp_function.png" src="../_images/cpp_function.png" />
</section>
<section id="understanding-ambiguities">
<h2>Understanding Ambiguities<a class="headerlink" href="#understanding-ambiguities" title="Permalink to this headline"></a></h2>
<p>The largest problem with allowing overloads and variadic functions is that it
becomes possible for a given set of arguments to resolve to more than one
overload. We say two overloads of a function, <span class="math notranslate nohighlight">\(O_a\)</span> and <span class="math notranslate nohighlight">\(O_b\)</span>, are
ambiguous if the same set of arguments constitutes a valid input for either
<span class="math notranslate nohighlight">\(O_a\)</span> or <span class="math notranslate nohighlight">\(O_b\)</span>. The purpose of this section is to work out the
scenarios under which <span class="math notranslate nohighlight">\(O_a\)</span> and <span class="math notranslate nohighlight">\(O_b\)</span> are ambiguous. To that end,
note that a non-variadic overload which takes <span class="math notranslate nohighlight">\(n\)</span> arguments can be thought
of as an ordered <span class="math notranslate nohighlight">\(n\)</span>-tuple such that the <span class="math notranslate nohighlight">\(i\)</span>-th element in the tuple
is the type of the <span class="math notranslate nohighlight">\(i\)</span>-th positional argument. A variadic overload with
<span class="math notranslate nohighlight">\((n-1)\)</span> required positional arguments can also be mapped to an
<span class="math notranslate nohighlight">\(n\)</span>-tuple such that the first <span class="math notranslate nohighlight">\((n-1)\)</span> elements of the tuple are the
types of the required positional arguments and the <span class="math notranslate nohighlight">\(n\)</span>-th element is an
opaque object holding the provided variadic arguments.</p>
<p>Without loss of generality, we assume that our two overloads, <span class="math notranslate nohighlight">\(O_a\)</span> and
<span class="math notranslate nohighlight">\(O_b\)</span> respectively take <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> total arguments such that
<span class="math notranslate nohighlight">\(n\le m\)</span>. As previously discussed, variadic arguments, if present, are
wrapped into a single opaque object. For variadic functions, the opaque object
is always the last element of the tuple. The first <span class="math notranslate nohighlight">\(\ell\)</span> elements of a
tuple will be denoted with a superscript, for example the first <span class="math notranslate nohighlight">\(\ell\)</span>
elements of <span class="math notranslate nohighlight">\(O_a\)</span> are denoted <span class="math notranslate nohighlight">\(O_a^{(\ell)}\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(n\)</span> equals <span class="math notranslate nohighlight">\(m\)</span>, there exists a trivial ambiguity when
<span class="math notranslate nohighlight">\(O_a^{(n)}\)</span> equals <span class="math notranslate nohighlight">\(O_b^{(m)}\)</span>, <em>i.e.</em>, the overloads are exactly
the same signature. For non-variadic functions this looks something like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Overload a with n == 2</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="p">)</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Implementation goes here</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="c"># Overload b with m == 2</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="p">)</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Implementation goes here</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>and for two variadic functions this looks like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Overload a with n == 2</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">args</span><span class="p">)</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Implementation goes here</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="c"># Overload b with m == 2</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">args</span><span class="p">)</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="p">)</span>
<span class="w">    </span><span class="c"># Implementation goes here</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>For <span class="math notranslate nohighlight">\(n == m\)</span>, there additionally exists one non-trivial ambiguity when
either <span class="math notranslate nohighlight">\(O_a\)</span> or <span class="math notranslate nohighlight">\(O_b\)</span> is variadic (if both are variadic only the
trivial ambiguity exists). If we arbitrarily take <span class="math notranslate nohighlight">\(O_a\)</span> as being variadic
then, for <span class="math notranslate nohighlight">\(n == m\)</span>, if <span class="math notranslate nohighlight">\(O_a^{(n-1)}\)</span> are the same as
<span class="math notranslate nohighlight">\(O_b^{(n-1)}\)</span> an ambiguity occurs. More concretely consider the following:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Overload a</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="w"> </span><span class="s">args</span><span class="p">)</span><span class="w"> </span><span class="c"># n == 3</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="c"># Overload b</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="w"> </span><span class="s">path</span><span class="p">)</span><span class="w"> </span><span class="c"># m == 3</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="w"> </span><span class="s">arg2</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>Here we can not distinguish a call to overload <span class="math notranslate nohighlight">\(O_b\)</span> from a call to
overload <span class="math notranslate nohighlight">\(O_a\)</span> with the <code class="docutils literal notranslate"><span class="pre">path</span></code> argument passed through <code class="docutils literal notranslate"><span class="pre">args</span></code>. In fact,
as long as overload <span class="math notranslate nohighlight">\(O_a\)</span> is variadic, this ambiguity is actually present
for any value of <span class="math notranslate nohighlight">\(n\)</span>. For example in:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Overload a</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">args</span><span class="p">)</span><span class="w"> </span><span class="c"># n == 2</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="c"># Overload b</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="w"> </span><span class="s">path</span><span class="p">)</span><span class="w"> </span><span class="c"># m == 3</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="w"> </span><span class="s">arg2</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>we can not distinguish a call to overload <span class="math notranslate nohighlight">\(O_b\)</span> from a call to overload
<span class="math notranslate nohighlight">\(O_a\)</span> with a <code class="docutils literal notranslate"><span class="pre">bool</span></code> and a <code class="docutils literal notranslate"><span class="pre">path</span></code> passed as <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
<p>So far we have accounted for all ambiguities when <span class="math notranslate nohighlight">\(O_a\)</span> is variadic. If
both <span class="math notranslate nohighlight">\(O_a\)</span> and <span class="math notranslate nohighlight">\(O_b\)</span> are non-variadic, then only the trivial
ambiguity is possible. If <span class="math notranslate nohighlight">\(O_a\)</span> is non-variadic, but <span class="math notranslate nohighlight">\(O_b\)</span> is
variadic an additional ambiguity occurs when <span class="math notranslate nohighlight">\(m = n + 1\)</span> and
<span class="math notranslate nohighlight">\(O_a^{(n)} == O_b^{(m-1)}\)</span>. This looks like:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Overload a</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="p">)</span><span class="w"> </span><span class="c"># n == 2</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="c"># Overload b</span>
<span class="nb">cpp_function</span><span class="p">(</span><span class="s">a_fxn</span><span class="w"> </span><span class="s">int</span><span class="w"> </span><span class="s">bool</span><span class="w"> </span><span class="s">args</span><span class="p">)</span><span class="w"> </span><span class="c"># m == 3</span>
<span class="nb">function</span><span class="p">(</span><span class="s2">&quot;${a_fxn}&quot;</span><span class="w"> </span><span class="s">arg0</span><span class="w"> </span><span class="s">arg1</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></div>
</div>
<p>Here we can not distinguish a call to <span class="math notranslate nohighlight">\(O_a\)</span> from a call to <span class="math notranslate nohighlight">\(O_b\)</span>
with no variadic arguments. These ambiguities are summarized in the following
table.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>Variadic?</p></th>
<th class="head" rowspan="2"><p>Ambiguous when:</p></th>
</tr>
<tr class="row-even"><th class="head"><p><span class="math notranslate nohighlight">\(O_a\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(O_b\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p><span class="math notranslate nohighlight">\(O_a^{(n-1)} == O_b^{(n-1)}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Yes</p></td>
<td><p>No</p></td>
<td><p><span class="math notranslate nohighlight">\(O_a^{(n-1)} == O_b^{(n-1)}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>No</p></td>
<td><p>Yes</p></td>
<td><p><span class="math notranslate nohighlight">\(O_a^{(m-1)} == O_b^{(m-1)}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>No</p></td>
<td><p>No</p></td>
<td><p><span class="math notranslate nohighlight">\(O_a^{(n)} == O_b^{(m)}\)</span></p></td>
</tr>
</tbody>
</table>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, CMakePP Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>