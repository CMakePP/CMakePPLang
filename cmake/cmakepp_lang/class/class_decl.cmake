# Copyright 2023 CMakePP
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#[[[ @module
# Defines functions to declare a user-defined CMakePPLang class.
#]]

include_guard()

include(cmakepp_lang/asserts/asserts)
include(cmakepp_lang/object/object)
include(cmakepp_lang/utilities/utilities)

#[[[
# Template file for creating a class.
#]]
set(
    __CMAKEPP_LANG_CLASS_TEMPLATE__
    "${CMAKE_CURRENT_LIST_DIR}/detail/class.cmake.in"
)

#[[[
# Creates a new class of the specified type.
#
# This command is used to start the declaration of a new user-defined type. The
# resulting user-defined type will automatically inherit from ``Object`` if no
# base classes are provided, otherwise it will inherit from the specified base
# classes (users of this command should never explicitly specify inheritance
# from ``Object``).
#
# :param type: The name of the class whose declaration is being started.
# :type type: desc
# :param \*args: The various base classes that the class should inherit from.
#
# :var CMAKEPP_LANG_DEBUG_MODE: Used to determine if CMakePP is being run in
#                               debug mode or not.
# :vartype CMAKEPP_LANG_DEBUG_MODE: bool
# 
# .. note::
#
#    This command is a macro to ensure that the functions generated by this
#    command are in scope to the caller.
#
# Error Checking
# ==============
#
# If CMakePP is run in debug mode (and only if it is run in debug mode) this
# function will assert that it was called with at least one argument and that
# the arguments have the correct types.
#]]
macro(cpp_class _c_type)
    cpp_assert_signature("${ARGV}" desc args)
    _cpp_class_guts("${_c_type}" "_${_c_type}_wrapper" ${ARGN})
    include("${_${_c_type}_wrapper}")
endmacro()

#[[[
# Denotes that we are done declaring a class.
#
# This function is a no-op that completes the fencing associated with declaring
# a class.
#
# Error Checking
# ==============
#
# None. This function is a no-op and has no errors to check for.
#]]
macro(cpp_end_class)
endmacro()

#[[[
# Creates the new class
#
# This function is factored out of ``cpp_class`` and contains the logic required
# to actually create the class. This logic is factored out primarily to avoid
# contaminating the caller's namespace with intermediate results.
#
# :param type: The name of the class being created.
# :type type: desc
# :param wrapper: Name for variable which will hold the path to the class's
#                     implementation.
# :type wrapper: desc
# :param \*args: The base classes that this class derives from.
# :returns: ``_cg_wrapper`` will be set to the absolute file path for the
#           generated module which implements the class.
# :rtype: path
#]]
function(_cpp_class_guts _cg_type _cg_wrapper)
    cpp_sanitize_string(_cg_nice_type "${_cg_type}")
    cpp_check_conflicting_types(
        _cg_conflict _cg_conflicting_type "${_cg_nice_type}"
    )
    if(_cg_conflict)
        message(
            FATAL_ERROR
            "Class name conflicts with a built-in type: "
            "'${_cg_type}' conflicts with built-in '${_cg_conflicting_type}'"
        )
    endif()

    if("${ARGC}" EQUAL 2)
        # No parent classes passed in, only inherit from obj
        set(_cg_bases "obj")
        # Use the obj singleton as the base instance
        set(_cg_base_instances "${__CMAKEPP_LANG_OBJECT_SINGLETON__}")
    else()
        set(_cg_bases "")
        set(_cg_base_instances "")
        foreach(_cg_base_i ${ARGN})
            cpp_get_global(_cg_default_base_i "${_cg_base_i}__state")
            list(APPEND _cg_base_instances "${_cg_default_base_i}")

            cpp_get_global(_cg_base_i_bases "${_cg_base_i}__bases")
            cpp_sanitize_string(_cg_nice_base "${_cg_base_i}")
            list(APPEND _cg_bases "${_cg_base_i_bases}" "${_cg_nice_base}")
        endforeach()
        list(REMOVE_DUPLICATES _cg_bases)
    endif()

    # Set the type before calling any ``Class`` members so we can type check
    _cpp_set_cmakepp_type("${_cg_type}" "class")

    _cpp_object_ctor(_cg_default "${_cg_type}" ${_cg_base_instances})
    _cpp_class_set_bases("${_cg_type}" _cg_bases)
    cpp_set_global("${_cg_type}__state" "${_cg_default}")

    set(
        "${_cg_wrapper}"
        "${CMAKE_CURRENT_BINARY_DIR}/cmakepp/classes/${_cg_type}.cmake"
    )
    configure_file(
       "${__CMAKEPP_LANG_CLASS_TEMPLATE__}" "${${_cg_wrapper}}" @ONLY
    )
    cpp_return("${_cg_wrapper}")
endfunction()
